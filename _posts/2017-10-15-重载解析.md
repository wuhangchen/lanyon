---
layout: post
title: 重载解析 
tags: [C++template overload]  
comments: true
category: review  
hide: true
--- 

## 引言
重载解析是一个过程，它针对所给的调用的表达式，来选择要进行调用的函数。如下所示：  
```C++   
	void display_num(int);  //(1)
	void display_num(double); // (2)
	int main()  
	{  
		display_num(388); //与(1)匹配的更好
		display_num(3.88); //与(2)匹配的更好  
	}
```  
C++编译器就必须使用一些额外的信息，来区分各个不同的候选函数。重载解析规则的大多数概念是非常简单的，当然，就像我们的教课书中描述一样的简单。但是在C++标准化的过程中，一些细节却变得非常的复杂。我下面将对重载解析规则进行更加详细的描述，然而，基于这个过程中，我不可能非常的面面俱到，但是能够应对大部分的问题。  
## C/C++差异  
和C++相比，C是一门简单的多的语言，这也恰好符合UNIX的精神。C里面没有类、对象、虚函数、异常处理、运行时的类型识别以及最重要的模板。  
重载解析，对于c 来说，同一个可执行的文件中的某个给定的函数只能够有单个的定义，从而他的二进制名字，符号名也只能有一个，这个符号名是经过简单的改变而来的，并且是与平台相关的；但是对于C++来说，函数(其实我喜欢用方法来描述)可以被重载，意思就是你可以定义同名的函数，为此编译器必须存在某种方式用于将各个重载版本的符号名(二进制名字)都某种方式来记忆区分。  
## 简化过的重载解析
重载解析通过比较调用实参和候选函数参数的匹配程度，来对所有的可行候选函数进行分级，对于匹配度级别高的候选函数，它的每个参数的匹配程度都不能低于匹配级别低的候选函数的相应参数的匹配程度。  
```C++  
	void combine(int ,double);  
	void combine(long ,int);
	
	int main()
	{
		combine(1,2);//二义性	
	}
	 
```  
C++并不会度量这种涉及到多个调用实参的相识度，从而引发二义性。  
根据分级的原则，我们需要指出调用实参和候选函数相应参数的匹配程度，给出一个分级的次序(从最佳匹配到最差匹配)  
- 完美匹配。参数类型和实参的类型完全相同，或者参数的类型是指向实参类型的引用，也可以增加const或者volatile限定符。  
- 有细微调整的匹配。如数组转变为指向数组第一个元素的的指针，或者添加const，从而让类型为int **的实参匹配类型为int const*const*的参数等。
- 发生提升的匹配。提升是一种隐式的转换，包含将占位符较少的整数类型(例如bool char short或者某些枚举类型)转换为占位符较多的整数的类型(例如int double等)，还包含从float到double类型的转换。  
- 发生标准转型(类型转换)的匹配。这包含任何种类的标准转型(诸如int到float),但是并不包含隐式调用的类型转换运算符和单构造函数。
- 发生用户自定义转型的匹配，允许任何种类的隐式类型转换。
- 和省略号的匹配。省略号可以匹配任何类型(但是不能匹配非POD类型)会导致未定义的行为。  
下面我用一些代码来说明：  
```C++  
	int f1(int);//(1)
	int f1(double);//(2)
	f1(4); //显然小白都知道调用(1):精确匹配
		   //而(2)需要一次标准转型    
	
	int f2(int);//(3)
	int f2(char);//(4)
	f2(true);//调用(3)，发生提升匹配，true是bool型
			 //而(4)是要求的标准转型。
			 //所以要搞清楚额，很多小伙伴可能会想都会调用(4),实际上，恰恰相反。  
	
	class X{
	public:  
		X(int);
	};  
	int f3(X);//(5);
	int f3(...);//(6);
	f3(7);//调用(5)：发生用户自定义转型的匹配。有小伙伴为什么要问这里为什么会发生自定义   
	       //类型的转换，那么请你阅读一下我的博客构造函数的滑铁卢explicit。因为构造函数能够进行隐式的转换。  
```  
需要额外补充的一点知识，重载解析在模板中是在模板实参演绎之后才进行的；因此，演绎并不会考虑上面的类型转换。  
## 小结
上面的原则只是一种近式的原则，在大多数的例子中符合这样的规定，然后c++天生就出现的那么诡异。我来举例出一些非常诡异的代码来说明这些情况，我们可能在编写的时候，无数次的会遇上这些，我们应该要知其然也知其所以然的道理。下面我放出第一个和编译器极度相关的代码，小伙伴可以看看，这样的代码哪儿出现问题：我会在下一次博客中讲述类似“习题课”。  
## 思考
	  
```C++  
#include<iostream>
#include<stddef.h>
using namespace std;
class BadString
{
public:
		BadString(char const*);
		//通过下标运算符来访问字符
		char& operator[](size_t);
		char const &operator[](size_t)const;
		//隐式转换为null结束的字符串
		operator char*();
		operator char const*();
};
int main()
{
 BadString str("correkt");
	 str[5] = 'c';         //发生error
	 return 0;
}  
```